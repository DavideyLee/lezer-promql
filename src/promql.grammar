@top PromQL { Expr }

@precedence {
  pow @right,
  mul @left,
  add @left,
  eql @left,
  and @left,
  or @left
}

Expr {
  AggregateExpr |
  BinaryExpr |
  FunctionCall |
  MatrixSelector |
  NumberLiteral |
  OffsetExpr |
  ParenExpr |
  StringLiteral |
  SubqueryExpr |
  UnaryExpr |
  VectorSelector
}

AggregateExpr {
  AggregateOp AggregateModifier FunctionCallBody |
  AggregateOp FunctionCallBody AggregateModifier |
  AggregateOp FunctionCallBody
}

AggregateOp {
  Avg |
  Bottomk |
  Count |
  CountValues |
  Group |
  Max |
  Min |
  Quantile |
  Stddev |
  Stdvar |
  Sum |
  Topk
}

AggregateModifier {
  By GroupingLabels |
  Without GroupingLabels
}

BinaryExpr {
  Expr !pow Pow        BinModifier Expr |
  Expr !mul Mul        BinModifier Expr |
  Expr !mul Div        BinModifier Expr |
  Expr !mul Mod        BinModifier Expr |
  Expr !add Add        BinModifier Expr |
  Expr !add Sub        BinModifier Expr |
  Expr !eql Eql        BinModifier Expr |
  Expr !eql Gte        BinModifier Expr |
  Expr !eql Gtr        BinModifier Expr |
  Expr !eql Lte        BinModifier Expr |
  Expr !eql Lss        BinModifier Expr |
  Expr !eql Neq        BinModifier Expr |
  Expr !and And        BinModifier Expr |
  Expr !and Unless     BinModifier Expr |
  Expr !or  Or         BinModifier Expr
}

BinModifier {
  GroupModifiers
}

BoolModifier {
  "" |
  Bool
}

OnOrIgnoring {
  BoolModifier Ignoring GroupingLabels |
  BoolModifier On GroupingLabels
}

GroupModifiers {
  BoolModifier |
  OnOrIgnoring |
  OnOrIgnoring GroupLeft MaybeGroupingLabels |
  OnOrIgnoring GroupRight MaybeGroupingLabels
}

MaybeGroupingLabels {
  "" | !mul GroupingLabels // TODO: Is the "!mul" here correct? Inserted it to resolve a shift/reduce conflict.
}

GroupingLabels {
  "(" GroupingLabelList ")" |
  "(" GroupingLabelList "," ")" |
  "(" ")"
}

GroupingLabelList {
  GroupingLabelList "," GroupingLabel |
  GroupingLabel
}

GroupingLabel {
  LabelName
}

FunctionCall {
  FunctionIdentifier FunctionCallBody
}

FunctionIdentifier {
  AbsentOverTime |
  Absent |
  Abs |
  AvgOverTime |
  Ceil |
  Changes |
  ClampMax |
  ClampMin |
  CountOverTime |
  DaysInMonth |
  DayOfMonth |
  DayOfWeek |
  Delta |
  Deriv |
  Exp |
  Floor |
  HistogramQuantile |
  HoltWinters |
  Hour |
  Idelta |
  Increase |
  Irate |
  LabelReplace |
  LabelJoin |
  Ln |
  Log10 |
  Log2 |
  MaxOverTime |
  MinOverTime |
  Minute |
  Month |
  PredictLinear |
  QuantileOverTime |
  Rate |
  Resets |
  Round |
  Scalar |
  Sort |
  SortDesc |
  Sqrt |
  StddevOverTime |
  StdvarOverTime |
  SumOverTime |
  Timestamp |
  Time |
  Vector |
  Year
}

FunctionCallBody {
  "(" FunctionCallArgs ")" |
  "(" ")"
}

FunctionCallArgs {
  FunctionCallArgs "," Expr |
  Expr
}

ParenExpr {
  "(" Expr ")"
}

OffsetExpr {
  Expr Offset Duration
}

MatrixSelector {
  // TODO: Can this not be more specific than "Expr"?
  Expr "[" Duration "]"
}

SubqueryExpr {
  Expr "[" Duration ":" ("" | Duration) "]"
}

UnaryExpr {
  !mul UnaryOp Expr
}

UnaryOp {
  "-" |
  "+"
}

VectorSelector {
  MetricIdentifier LabelMatchers |
  MetricIdentifier |
  LabelMatchers
}

LabelMatchers {
  "{" LabelMatchList "}" |
  "{" LabelMatchList "," "}" |
  "{" "}"
}

LabelMatchList {
  LabelMatchList "," LabelMatcher |
  LabelMatcher
}

MatchOp {
  EqlSingle |
  Neq |
  EqlRegex |
  NeqRegex
}

LabelMatcher {
  LabelName MatchOp StringLiteral
}

MetricIdentifier {
  Identifier
}

@skip { whitespace | LineComment }

@tokens {
  whitespace { std.whitespace+ }
  LineComment { "#" ![\n]* }

  NumberLiteral { // TODO: Handle NaN etc.
    (std.digit+ ("." std.digit*)? | "." std.digit+) (("e" | "E") ("+" | "-")? std.digit+)? |
    "0x" (std.digit | $[a-fA-F])+
  }
  StringLiteral { // TODO: This is for JS, make this work for PromQL.
    '"' (![\\\n"] | "\\" _)* '"'? |
    "'" (![\\\n'] | "\\" _)* "'"? |
    "`" ![`]* "`"
  }

  Duration {
    // Each line below is just the same regex repeated over and over, but each time with one of the units made non-optional,
    // to ensure that at least one <number>+<unit> pair is provided and an empty string is not recognized as a valid duration.
    ( ( std.digit+ "y" ) ( std.digit+ "w" )? ( std.digit+ "d" )? ( std.digit+ "h" )? ( std.digit+ "m" )? ( std.digit+ "s" )? ( std.digit+ "ms" )? ) |
    ( ( std.digit+ "y" )? ( std.digit+ "w" ) ( std.digit+ "d" )? ( std.digit+ "h" )? ( std.digit+ "m" )? ( std.digit+ "s" )? ( std.digit+ "ms" )? ) |
    ( ( std.digit+ "y" )? ( std.digit+ "w" )? ( std.digit+ "d" ) ( std.digit+ "h" )? ( std.digit+ "m" )? ( std.digit+ "s" )? ( std.digit+ "ms" )? ) |
    ( ( std.digit+ "y" )? ( std.digit+ "w" )? ( std.digit+ "d" )? ( std.digit+ "h" ) ( std.digit+ "m" )? ( std.digit+ "s" )? ( std.digit+ "ms" )? ) |
    ( ( std.digit+ "y" )? ( std.digit+ "w" )? ( std.digit+ "d" )? ( std.digit+ "h" )? ( std.digit+ "m" ) ( std.digit+ "s" )? ( std.digit+ "ms" )? ) |
    ( ( std.digit+ "y" )? ( std.digit+ "w" )? ( std.digit+ "d" )? ( std.digit+ "h" )? ( std.digit+ "m" )? ( std.digit+ "s" ) ( std.digit+ "ms" )? ) |
    ( ( std.digit+ "y" )? ( std.digit+ "w" )? ( std.digit+ "d" )? ( std.digit+ "h" )? ( std.digit+ "m" )? ( std.digit+ "s" )? ( std.digit+ "ms" ) )
  }
  Identifier { (std.asciiLetter | "_" | ":") (std.asciiLetter | std.digit | "_" | ":" )*}
  LabelName { (std.asciiLetter | "_") (std.asciiLetter | std.digit | "_")* }

  // Operator
  Sub { "-" }
  Add { "+" }
  Mul { "*" }
  Mod { "%" }
  Div { "/" }
  Eql { "==" }
  Neq { "!=" }
  Lte { "<=" }
  Lss { "<" }
  Gte { ">=" }
  Gtr { ">" }
  EqlRegex { "=~" }
  EqlSingle { "=" }
  NeqRegex { "!~" }
  Pow { "^" }
}

// Keywords

@external specialize {Identifier} specializeIdentifier from "./tokens" {
  Bool,
  Ignoring,
  On,
  GroupLeft,
  GroupRight,
  Offset
}

// Contextual keywords

@external extend {Identifier} extendIdentifier from "./tokens" {
  Avg,
  Bottomk,
  Count,
  CountValues,
  Group,
  Max,
  Min,
  Quantile,
  Stddev,
  Stdvar,
  Sum,
  Topk,
  By,
  Without,
  And,
  Or,
  Unless
}

  // FunctionIdentifier definitions
  Abs { condFn<"abs"> }
  Absent { condFn<"absent"> }
  AbsentOverTime { condFn<"absent_over_time"> }
  AvgOverTime { condFn<"avg_over_time"> }
  Ceil { condFn<"ceil"> }
  Changes { condFn<"changes"> }
  ClampMax { condFn<"clamp_max"> }
  ClampMin { condFn<"clamp_min"> }
  CountOverTime { condFn<"count_over_time"> }
  DaysInMonth { condFn<"days_in_month"> }
  DayOfMonth { condFn<"day_of_month"> }
  DayOfWeek { condFn<"day_of_week"> }
  Delta { condFn<"delta"> }
  Deriv { condFn<"deriv"> }
  Exp { condFn<"exp"> }
  Floor { condFn<"floor"> }
  HistogramQuantile { condFn<"histogram_quantile"> }
  HoltWinters { condFn<"holt_winters"> }
  Hour { condFn<"hour"> }
  Idelta { condFn<"idelta"> }
  Increase { condFn<"increase"> }
  Irate { condFn<"irate"> }
  LabelReplace { condFn<"label_replace"> }
  LabelJoin { condFn<"label_join"> }
  Ln { condFn<"ln"> }
  Log10 { condFn<"log10"> }
  Log2 { condFn<"log2"> }
  MaxOverTime { condFn<"max_over_time"> }
  MinOverTime { condFn<"min_over_time"> }
  Minute { condFn<"minute"> }
  Month { condFn<"month"> }
  PredictLinear { condFn<"predict_linear"> }
  QuantileOverTime { condFn<"quantile_over_time"> }
  Rate { condFn<"rate"> }
  Resets { condFn<"resets"> }
  Round { condFn<"round"> }
  Scalar { condFn<"scalar"> }
  Sort { condFn<"sort"> }
  SortDesc { condFn<"sort_desc"> }
  Sqrt { condFn<"sqrt"> }
  StddevOverTime { condFn<"stddev_over_time"> }
  StdvarOverTime { condFn<"stdvar_over_time"> }
  SumOverTime { condFn<"sum_over_time"> }
  Time { condFn<"time"> }
  Timestamp { condFn<"timestamp"> }
  Vector { condFn<"vector"> }
  Year { condFn<"year"> }

// Conditional function names (only parsed as function names when used as such).
condFn<term> { @extend<Identifier, term> }
