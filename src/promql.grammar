@top { Expr }

@precedence {
  pow @right,
  mul @left,
  add @left,
  eql @left,
  and @left,
  or @left
}

Expr {
  AggregateExpr |
  BinaryExpr |
  FunctionCall |
  MatrixSelector |
  NumberLiteral |
  OffsetExpr |
  ParenExpr |
  StringLiteral |
  SubqueryExpr |
  UnaryExpr |
  VectorSelector
}

AggregateExpr {
  AggregateOp AggregateModifier FunctionCallBody |
  AggregateOp FunctionCallBody AggregateModifier |
  AggregateOp FunctionCallBody
}

AggregateOp {
  ckw<"avg"> |
  ckw<"bottomk"> |
  ckw<"count"> |
  ckw<"count_values"> |
  ckw<"group"> |
  ckw<"max"> |
  ckw<"min"> |
  ckw<"quantile"> |
  ckw<"stddev"> |
  ckw<"stdvar"> |
  ckw<"sum"> |
  ckw<"topk">
}

AggregateModifier {
  By GroupingLabels |
  Without GroupingLabels
}

By {
  ckw<"by"> // TODO: Handle case-insensitivity for keywords everywhere.
}

Without {
  ckw<"without">
}

BinaryExpr {
  Expr !pow BinOp<"^">    BinModifier Expr |
  Expr !mul BinOp<"*">    BinModifier Expr |
  Expr !mul BinOp<"/">    BinModifier Expr |
  Expr !mul BinOp<"%">    BinModifier Expr |
  Expr !add BinOp<"+">    BinModifier Expr |
  Expr !add BinOp<"-">    BinModifier Expr |
  Expr !eql BinOp<"==">   BinModifier Expr |
  Expr !eql BinOp<">=">   BinModifier Expr |
  Expr !eql BinOp<">">    BinModifier Expr |
  Expr !eql BinOp<"<">    BinModifier Expr |
  Expr !eql BinOp<"<=">   BinModifier Expr |
  Expr !eql BinOp<"!=">   BinModifier Expr |
  Expr !and ckw<"and">    BinModifier Expr |
  Expr !and ckw<"unless"> BinModifier Expr |
  Expr !or  ckw<"or">     BinModifier Expr
}

BinModifier {
  GroupModifiers
}

BoolModifier {
  "" |
  Bool
}

Bool {
  kw<"bool"> // TODO: Handle case-insensitivity everywhere.
}

OnOrIgnoring {
  BoolModifier Ignoring GroupingLabels |
  BoolModifier On GroupingLabels
}

Ignoring {
  kw<"ignoring">
}

On {
  kw<"on">
}

GroupModifiers {
  BoolModifier |
  OnOrIgnoring |
  OnOrIgnoring GroupLeft MaybeGroupingLabels |
  OnOrIgnoring GroupRight MaybeGroupingLabels
}

MaybeGroupingLabels {
  "" | !mul GroupingLabels // TODO: Is the "!mul" here correct? Inserted it to resolve a shift/reduce conflict.
}

GroupLeft {
  kw<"group_left">
}

GroupRight {
  kw<"group_right">
}

GroupingLabels {
  "(" GroupingLabelList ")" |
  "(" GroupingLabelList "," ")" |
  "(" ")"
}

GroupingLabelList {
  GroupingLabelList "," GroupingLabel |
  GroupingLabel
}

GroupingLabel {
  LabelName
}

FunctionCall {
  FunctionIdentifier FunctionCallBody
}

FunctionIdentifier {
	ckw<"abs"> |
	ckw<"absent"> |
	ckw<"absent_over_time"> |
	ckw<"avg_over_time"> |
	ckw<"ceil"> |
	ckw<"changes"> |
	ckw<"clamp_max"> |
	ckw<"clamp_min"> |
	ckw<"count_over_time"> |
	ckw<"days_in_month"> |
	ckw<"day_of_month"> |
	ckw<"day_of_week"> |
	ckw<"delta"> |
	ckw<"deriv"> |
	ckw<"exp"> |
	ckw<"floor"> |
	ckw<"histogram_quantile"> |
	ckw<"holt_winters"> |
	ckw<"hour"> |
	ckw<"idelta"> |
	ckw<"increase"> |
	ckw<"irate"> |
	ckw<"label_replace"> |
	ckw<"label_join"> |
	ckw<"ln"> |
	ckw<"log10"> |
	ckw<"log2"> |
	ckw<"max_over_time"> |
	ckw<"min_over_time"> |
	ckw<"minute"> |
	ckw<"month"> |
	ckw<"predict_linear"> |
	ckw<"quantile_over_time"> |
	ckw<"rate"> |
	ckw<"resets"> |
	ckw<"round"> |
	ckw<"scalar"> |
	ckw<"sort"> |
	ckw<"sort_desc"> |
	ckw<"sqrt"> |
	ckw<"stddev_over_time"> |
	ckw<"stdvar_over_time"> |
	ckw<"sum_over_time"> |
	ckw<"time"> |
	ckw<"timestamp"> |
	ckw<"vector"> |
	ckw<"year">
}

FunctionCallBody {
  "(" FunctionCallArgs ")" |
  "(" ")"
}

FunctionCallArgs {
  FunctionCallArgs "," Expr |
  Expr |
  FunctionCallArgs ","
}

ParenExpr {
  "(" Expr ")"
}

OffsetExpr {
  Expr Offset Duration
}

Offset {
  kw<"offset">
}

MatrixSelector {
  // TODO: Can this not be more specific than "Expr"?
  Expr "[" Duration "]"
}

SubqueryExpr {
  Expr "[" Duration ":" ("" | Duration) "]"
}

UnaryExpr {
  !mul UnaryOp Expr
}

UnaryOp {
  "-" |
  "+"
}

VectorSelector {
  MetricIdentifier LabelMatchers |
  MetricIdentifier |
  LabelMatchers
}

LabelMatchers {
  "{" LabelMatchList "}" |
  "{" LabelMatchList "," "}" |
  "{" "}"
}

LabelMatchList {
  LabelMatchList "," LabelMatcher |
  LabelMatcher
}

LabelMatcher {
  LabelName (MatchOp<"="> | MatchOp<"!="> | MatchOp<"=~"> | MatchOp<"!~">) StringLiteral
}

MetricIdentifier {
  Identifier
}

@skip { whitespace | LineComment }

@tokens {
  whitespace { std.whitespace+ }
  LineComment { "#" ![\n]* }

  NumberLiteral { // TODO: Handle NaN etc.
    (std.digit+ ("." std.digit*)? | "." std.digit+) (("e" | "E") ("+" | "-")? std.digit+)? |
    "0x" (std.digit | $[a-fA-F])+
  }
  StringLiteral { // TODO: This is for JS, make this work for PromQL.
    '"' (![\\\n"] | "\\" _)* '"'? |
    "'" (![\\\n'] | "\\" _)* "'"? |
    "`" ![`]* "`"
  }

  Duration { std.digit+ ("s" | "m" | "h" | "d" | "w" | "y")}
  Identifier { (std.asciiLetter | "_" | ":") (std.asciiLetter | std.digit | "_" | ":" )*}
  LabelName { (std.asciiLetter | "_") (std.asciiLetter | std.digit | "_")* }

  BinOp<expr> { expr }
  MatchOp<expr> { expr }
}

// Keywords

kw<term> { @specialize[name={term}]<Identifier, term> }

// Contextual keywords

ckw<term> { @extend[name={term}]<Identifier, term> }
